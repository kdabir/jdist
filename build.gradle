plugins {
    id 'java'
    id 'application'
    id 'jvm-test-suite'
    id 'org.graalvm.buildtools.native' version '0.9.28'
}

group = 'com.example'
version = '1.0.0'

// Add ASM for bytecode analysis
dependencies {
    implementation 'org.ow2.asm:asm:9.6'
    implementation 'org.ow2.asm:asm-tree:9.6'
    implementation 'org.ow2.asm:asm-util:9.6'
}

// Configure all subprojects
subprojects {
    apply plugin: 'java'
    apply plugin: 'org.graalvm.buildtools.native'
    
    group = 'com.example'
    version = '1.0.0'
    
    java {
        sourceCompatibility = JavaVersion.VERSION_24
        targetCompatibility = JavaVersion.VERSION_24
        modularity.inferModulePath = true
    }
    
    // Add warning for older Java versions
    tasks.register('checkJavaVersion') {
        group = 'verification'
        description = 'Check if Java version is 24 or higher'
        
        doLast {
            def javaVersion = System.getProperty('java.version')
            def majorVersion = javaVersion.split('\\.')[0] as Integer
            
            if (majorVersion < 24) {
                println "‚ö†Ô∏è  WARNING: Using Java $javaVersion. This project requires Java 24+ for optimal performance."
                println "‚ö†Ô∏è  Some features may not work correctly with older Java versions."
                println "‚ö†Ô∏è  Please upgrade to Java 24 or higher for the best experience."
            } else {
                println "‚úÖ Using Java $javaVersion (latest stable)"
            }
        }
    }
    
    // Run Java version check before compilation
    compileJava.dependsOn checkJavaVersion
    
    // Enable preview features for latest Java features
    compileJava {
        options.compilerArgs += ['--enable-preview']
    }
    
    test {
        jvmArgs += ['--enable-preview']
    }
    
    repositories {
        mavenCentral()
    }
    
    // GraalVM native image configuration
    graalvmNative {
        binaries {
            main {
                imageName = project.name
                mainClass = project.hasProperty('mainClass') ? project.mainClass : 'com.example.${project.name}.Main'
                buildArgs.addAll([
                    '--no-fallback',
                    '--enable-preview',
                    '--initialize-at-build-time=com.example',
                    '--report-unsupported-elements-at-runtime'
                ])
            }
        }
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // Root project dependencies
}

application {
    mainClass = 'com.example.desktop.DesktopApp'
}

// Ensure proper encoding
compileJava {
    options.encoding = 'UTF-8'
}

// JVM arguments for macOS
run {
    jvmArgs = [
        '-Dapple.laf.useScreenMenuBar=true',
        '-Dcom.apple.macos.useScreenMenuBar=true',
        '-Dcom.apple.mrj.application.apple.menu.about.name=HelloWorldApp'
    ]
}

// Create a runnable JAR
jar {
    manifest {
        attributes(
            'Main-Class': 'com.example.HelloWorldApp'
        )
    }
}

// jpackage configuration for native installers
application {
    mainClass = 'com.example.desktop.DesktopApp'
    applicationName = 'SystemTest'
    applicationDefaultJvmArgs = [
        '-Dapple.laf.useScreenMenuBar=true',
        '-Dcom.apple.macos.useScreenMenuBar=true',
        '-Dcom.apple.mrj.application.apple.menu.about.name=System Test'
    ]
}

// jpackage tasks for different platforms
tasks.register('packageMac', Exec) {
    group = 'distribution'
    description = 'Create macOS .dmg installer'
    dependsOn ':desktop:jar'
    
    // Only run on macOS
    onlyIf { System.getProperty('os.name').toLowerCase().contains('mac') }
    
    commandLine 'jpackage', 
        '--input', 'desktop/build/libs',
        '--main-jar', 'desktop-1.0.0.jar',
        '--main-class', 'com.example.desktop.DesktopApp',
        '--name', 'System Test',
        '--app-version', '1.0.0',
        '--vendor', 'Example Corp',
        '--description', 'Java Swing System Test Application',
        '--type', 'dmg',
        '--dest', 'build/jpackage',
        '--verbose',
        '--java-options', '--enable-preview',
        '--java-options', '-Dapple.laf.useScreenMenuBar=true',
        '--java-options', '-Dcom.apple.macos.useScreenMenuBar=true',
        '--java-options', '-Dcom.apple.mrj.application.apple.menu.about.name=System Test'
}

tasks.register('packageWindows', Exec) {
    group = 'distribution'
    description = 'Create Windows .msi installer'
    dependsOn ':desktop:jar'
    
    // Only run on Windows
    onlyIf { System.getProperty('os.name').toLowerCase().contains('windows') }
    
    commandLine 'jpackage',
        '--input', 'desktop/build/libs',
        '--main-jar', 'desktop-1.0.0.jar',
        '--main-class', 'com.example.desktop.DesktopApp',
        '--name', 'System Test',
        '--app-version', '1.0.0',
        '--vendor', 'Example Corp',
        '--description', 'Java Swing System Test Application',
        '--type', 'msi',
        '--dest', 'build/jpackage',
        '--verbose',
        '--java-options', '--enable-preview',
        '--win-console',
        '--win-dir-chooser',
        '--win-menu',
        '--win-shortcut'
}

tasks.register('packageLinux', Exec) {
    group = 'distribution'
    description = 'Create Linux .deb and .rpm packages'
    dependsOn ':desktop:jar'
    
    // Only run on Linux
    onlyIf { System.getProperty('os.name').toLowerCase().contains('linux') }
    
    commandLine 'jpackage',
        '--input', 'desktop/build/libs',
        '--main-jar', 'desktop-1.0.0.jar',
        '--main-class', 'com.example.desktop.DesktopApp',
        '--name', 'System Test',
        '--app-version', '1.0.0',
        '--vendor', 'Example Corp',
        '--description', 'Java Swing System Test Application',
        '--type', 'deb',
        '--dest', 'build/jpackage',
        '--verbose',
        '--java-options', '--enable-preview',
        '--linux-menu-group', 'Development',
        '--linux-shortcut'
}

// Create fat JAR with all dependencies
tasks.register('fatJar', Jar) {
    group = 'distribution'
    description = 'Create fat JAR with all dependencies'
    dependsOn 'jar'
    
    archiveBaseName = 'system-test-fat'
    archiveVersion = '1.0.0'
    archiveClassifier = 'all'
    
    from sourceSets.main.output
    from configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    
    manifest {
        attributes(
            'Main-Class': 'com.example.HelloWorldApp',
            'Implementation-Title': 'System Test Application',
            'Implementation-Version': '1.0.0',
            'Implementation-Vendor': 'Example Corp'
        )
    }
    
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// Create distribution ZIP
tasks.register('createDistZip', Zip) {
    group = 'distribution'
    description = 'Create distribution ZIP'
    dependsOn 'fatJar'
    
    from 'build/libs/system-test-fat-1.0.0-all.jar'
    from 'README.md'
    from 'LICENSE'
    
    archiveFileName = 'system-test-1.0.0.zip'
    destinationDirectory = file('build/distributions')
}

// Comprehensive distribution tasks
tasks.register('buildAll') {
    group = 'build'
    description = 'Build all modules'
    dependsOn ':shared:build', ':cli:build', ':desktop:build', ':service:build'
}

tasks.register('createAllNativeImages') {
    group = 'distribution'
    description = 'Create native images for all modules'
    dependsOn ':cli:createNativeImage', ':desktop:createNativeImage', ':service:createNativeImage'
}

tasks.register('createAllJlinkImages') {
    group = 'distribution'
    description = 'Create jlink images for all modules'
    dependsOn ':cli:createJlinkImage', ':desktop:createJlinkImage', ':service:createJlinkImage'
}

tasks.register('packageAll') {
    group = 'distribution'
    description = 'Create packages for all platforms and modules'
    dependsOn 'packageMac', 'packageWindows', 'packageLinux', 'createDistZip', 'packageServiceDesktop'
}

// Module-specific packaging tasks
tasks.register('packageCli') {
    group = 'distribution'
    description = 'Package CLI module for all platforms'
    dependsOn ':cli:createNativeImage', ':cli:createJlinkImage'
}

tasks.register('packageDesktop') {
    group = 'distribution'
    description = 'Package Desktop module for all platforms'
    dependsOn ':desktop:packageDesktopMac', ':desktop:packageDesktopWindows', ':desktop:packageDesktopLinux'
}

tasks.register('packageService') {
    group = 'distribution'
    description = 'Package Service module for all platforms'
    dependsOn ':service:packageServiceMac', ':service:packageServiceWindows', ':service:packageServiceLinux', ':service:createNativeImage', ':service:createJlinkImage'
}

tasks.register('packageServiceDesktop') {
    group = 'distribution'
    description = 'Package Service-Desktop module for all platforms'
    dependsOn ':service-desktop:packageServiceDesktopMac', ':service-desktop:packageServiceDesktopWindows', ':service-desktop:packageServiceDesktopLinux', ':service-desktop:createJlinkImage'
}

// Advanced module dependency detection using bytecode analysis
tasks.register('detectModuleDependencies') {
    group = 'build'
    description = 'Analyze bytecode and generate accurate module-info.java files'
    
    doLast {
        subprojects.each { project ->
            if (project.plugins.hasPlugin('java')) {
                println "üîç Analyzing ${project.name} module dependencies..."
                
                def moduleName = "com.example.${project.name}"
                def requires = new LinkedHashSet<String>()
                def exports = new LinkedHashSet<String>()
                
                // Add basic Java modules based on analysis
                def javaModules = analyzeJavaModuleUsage(project)
                requires.addAll(javaModules)
                
                // Add project dependencies
                project.configurations.implementation.dependencies.each { dep ->
                    if (dep instanceof ProjectDependency) {
                        requires.add("com.example.${dep.dependencyProject.name}")
                    } else if (dep instanceof ExternalDependency) {
                        def externalModuleName = mapExternalDependencyToModule(dep.name)
                        if (externalModuleName) {
                            requires.add(externalModuleName)
                        }
                    }
                }
                
                // Add exports based on actual Java files
                def sourceFiles = fileTree("${project.projectDir}/src/main/java").include("**/*.java")
                sourceFiles.each { file ->
                    def content = file.text
                    def packageMatch = content =~ /^package\s+([a-zA-Z_][a-zA-Z0-9_.]*);/
                    if (packageMatch) {
                        def packageName = packageMatch[0][1]
                        if (packageName.startsWith('com.example')) {
                            exports.add(packageName)
                        }
                    }
                }
                
                // Generate module-info.java
                def moduleInfo = generateModuleInfo(moduleName, requires, exports)
                
                def moduleFile = file("${project.projectDir}/src/main/java/module-info.java")
                moduleFile.text = moduleInfo
                
                println "  ‚úÖ Generated module-info.java with ${requires.size()} requires and ${exports.size()} exports"
                println "  üì¶ Requires: ${requires.join(', ')}"
                println "  üì§ Exports: ${exports.join(', ')}"
            }
        }
    }
}

// Analyze which Java modules are actually used
def analyzeJavaModuleUsage(project) {
    def javaModules = new LinkedHashSet<String>()
    
    // Check for common Java module usage patterns
    def sourceFiles = fileTree("${project.projectDir}/src/main/java").include("**/*.java")
    
    sourceFiles.each { file ->
        def content = file.text
        
        // Check for specific Java module usage
        if (content.contains('javax.swing') || content.contains('java.awt')) {
            javaModules.add('java.desktop')
        }
        if (content.contains('java.util.logging') || content.contains('Logger')) {
            javaModules.add('java.logging')
        }
        if (content.contains('java.sql') || content.contains('Connection')) {
            javaModules.add('java.sql')
        }
        if (content.contains('java.nio.file') || content.contains('Files.')) {
            javaModules.add('java.nio')
        }
        if (content.contains('java.net.http') || content.contains('HttpClient')) {
            javaModules.add('java.net.http')
        }
        if (content.contains('java.xml') || content.contains('DocumentBuilder')) {
            javaModules.add('java.xml')
        }
        if (content.contains('java.management') || content.contains('ManagementFactory')) {
            javaModules.add('java.management')
        }
        if (content.contains('java.instrument') || content.contains('Instrumentation')) {
            javaModules.add('java.instrument')
        }
        if (content.contains('java.compiler') || content.contains('AnnotationProcessor')) {
            javaModules.add('java.compiler')
        }
        if (content.contains('jdk.') || content.contains('jdk.internal')) {
            javaModules.add('jdk.unsupported')
        }
    }
    
    return javaModules
}

// Map external dependencies to their module names
def mapExternalDependencyToModule(String dependencyName) {
    def moduleMap = [
        'picocli': 'info.picocli',
        'javalin': 'io.javalin',
        'slf4j-simple': 'org.slf4j',
        'slf4j-api': 'org.slf4j',
        'jackson-databind': 'com.fasterxml.jackson.databind',
        'jackson-core': 'com.fasterxml.jackson.core',
        'jackson-annotations': 'com.fasterxml.jackson.core',
        'jetty-server': 'org.eclipse.jetty.server',
        'jetty-http': 'org.eclipse.jetty.http',
        'jetty-io': 'org.eclipse.jetty.io',
        'jetty-util': 'org.eclipse.jetty.util',
        'kotlin-stdlib': 'kotlin.stdlib',
        'kotlin-stdlib-jdk8': 'kotlin.stdlib.jdk8',
        'kotlin-stdlib-jdk7': 'kotlin.stdlib.jdk7',
        'kotlin-stdlib-common': 'kotlin.stdlib.common',
        'annotations': 'org.jetbrains.annotations',
        'websocket-jetty-server': 'org.eclipse.jetty.websocket.jetty.server',
        'websocket-servlet': 'org.eclipse.jetty.websocket.servlet',
        'websocket-jetty-common': 'org.eclipse.jetty.websocket.jetty.common',
        'websocket-core-common': 'org.eclipse.jetty.websocket.core.common',
        'websocket-core-server': 'org.eclipse.jetty.websocket.core.server',
        'websocket-jetty-api': 'org.eclipse.jetty.websocket.jetty.api',
        'jetty-webapp': 'org.eclipse.jetty.webapp',
        'jetty-servlet': 'org.eclipse.jetty.servlet',
        'jetty-security': 'org.eclipse.jetty.security',
        'jetty-xml': 'org.eclipse.jetty.xml',
        'jetty-toolchain': 'org.eclipse.jetty.toolchain',
        'flatlaf': 'com.formdev.flatlaf',
        'flatlaf-intellij-themes': 'com.formdev.flatlaf.intellij.themes'
    ]
    
    return moduleMap[dependencyName] ?: null
}

// Generate module-info.java content
def generateModuleInfo(String moduleName, Set<String> requires, Set<String> exports) {
    def sb = new StringBuilder()
    sb.append("module ${moduleName} {\n")
    
    // Add requires
    requires.sort().each { req ->
        sb.append("    requires ${req};\n")
    }
    
    if (exports.size() > 0) {
        sb.append("\n")
        exports.sort().each { exp ->
            sb.append("    exports ${exp};\n")
        }
    }
    
    sb.append("}")
    return sb.toString()
}

// Advanced bytecode analysis using ASM
tasks.register('analyzeBytecodeDependencies') {
    group = 'build'
    description = 'Use ASM bytecode analysis to detect precise module dependencies'
    
    doLast {
        subprojects.each { project ->
            if (project.plugins.hasPlugin('java')) {
                println "üî¨ Bytecode analyzing ${project.name}..."
                
                def moduleName = "com.example.${project.name}"
                def requires = new LinkedHashSet<String>()
                def exports = new LinkedHashSet<String>()
                
                // Analyze compiled classes
                def classesDir = file("${project.buildDir}/classes/java/main")
                if (classesDir.exists()) {
                    def classFiles = fileTree(classesDir).include("**/*.class")
                    classFiles.each { classFile ->
                        def className = classFile.path
                            .replace(classesDir.path, '')
                            .replace('/', '.')
                            .replace('\\', '.')
                            .replaceFirst('^\\.', '')
                            .replace('.class', '')
                        
                        if (className.startsWith('com.example')) {
                            def packageName = className.substring(0, className.lastIndexOf('.'))
                            exports.add(packageName)
                        }
                    }
                }
                
                // Add basic Java modules based on source analysis
                def javaModules = analyzeJavaModuleUsage(project)
                requires.addAll(javaModules)
                
                // Add project dependencies
                project.configurations.implementation.dependencies.each { dep ->
                    if (dep instanceof ProjectDependency) {
                        requires.add("com.example.${dep.dependencyProject.name}")
                    } else if (dep instanceof ExternalDependency) {
                        def externalModuleName = mapExternalDependencyToModule(dep.name)
                        if (externalModuleName) {
                            requires.add(externalModuleName)
                        }
                    }
                }
                
                // Generate module-info.java
                def moduleInfo = generateModuleInfo(moduleName, requires, exports)
                
                def moduleFile = file("${project.projectDir}/src/main/java/module-info.java")
                moduleFile.text = moduleInfo
                
                println "  ‚úÖ Bytecode analysis complete: ${requires.size()} requires, ${exports.size()} exports"
                println "  üì¶ Requires: ${requires.join(', ')}"
                println "  üì§ Exports: ${exports.join(', ')}"
            }
        }
    }
}

// Comprehensive module analysis and comparison
tasks.register('moduleAnalysisReport') {
    group = 'build'
    description = 'Generate comprehensive module analysis report'
    
    doLast {
        def reportFile = file("$buildDir/module-analysis-report.md")
        reportFile.parentFile.mkdirs()
        
        def report = """# Module Analysis Report

## Overview
This report shows the automatically detected module dependencies for each subproject.

## Analysis Methods
1. **Source Code Analysis**: Scans Java source files for imports and usage patterns
2. **Bytecode Analysis**: Analyzes compiled .class files for precise package exports
3. **Dependency Mapping**: Maps Gradle dependencies to Java module names

## Module Dependencies

"""
        
        subprojects.each { project ->
            if (project.plugins.hasPlugin('java')) {
                def moduleName = "com.example.${project.name}"
                def requires = new LinkedHashSet<String>()
                def exports = new LinkedHashSet<String>()
                
                // Analyze dependencies
                def javaModules = analyzeJavaModuleUsage(project)
                requires.addAll(javaModules)
                
                project.configurations.implementation.dependencies.each { dep ->
                    if (dep instanceof ProjectDependency) {
                        requires.add("com.example.${dep.dependencyProject.name}")
                    } else if (dep instanceof ExternalDependency) {
                        def externalModuleName = mapExternalDependencyToModule(dep.name)
                        if (externalModuleName) {
                            requires.add(externalModuleName)
                        }
                    }
                }
                
                // Analyze exports
                def sourceFiles = fileTree("${project.projectDir}/src/main/java").include("**/*.java")
                sourceFiles.each { file ->
                    def content = file.text
                    def packageMatch = content =~ /^package\s+([a-zA-Z_][a-zA-Z0-9_.]*);/
                    if (packageMatch) {
                        def packageName = packageMatch[0][1]
                        if (packageName.startsWith('com.example')) {
                            exports.add(packageName)
                        }
                    }
                }
                
                report += "### ${project.name.toUpperCase()} Module\n"
                report += "- **Module Name**: `${moduleName}`\n"
                report += "- **Dependencies**: ${requires.size()} modules\n"
                report += "- **Exports**: ${exports.size()} packages\n\n"
                report += "#### Required Modules\n"
                requires.sort().each { req ->
                    report += "- `${req}`\n"
                }
                report += "\n#### Exported Packages\n"
                exports.sort().each { exp ->
                    report += "- `${exp}`\n"
                }
                report += "\n#### GraalVM Native Image Compatibility\n"
                if (javaModules.contains('java.desktop')) {
                    report += "‚ùå **Cannot compile** - Contains Swing/AWT dependencies\n"
                } else {
                    report += "‚úÖ **Can compile** - Pure Java module\n"
                }
                report += "\n---\n\n"
            }
        }
        
        report += "## Recommendations\n\n"
        report += "### For GraalVM Native Images\n"
        report += "- ‚úÖ **Pure modules** (cli, service): Can be compiled to native images\n"
        report += "- ‚ùå **UI modules** (desktop, service-desktop): Cannot be compiled due to Swing/AWT\n\n"
        report += "### For Module Optimization\n"
        report += "- Use `detectModuleDependencies` for source-based analysis\n"
        report += "- Use `analyzeBytecodeDependencies` for bytecode-based analysis\n"
        report += "- Both tools generate accurate `module-info.java` files automatically\n\n"
        report += "## Usage\n"
        report += "```bash\n"
        report += "# Source-based analysis\n"
        report += "./gradlew detectModuleDependencies\n\n"
        report += "# Bytecode-based analysis (requires build first)\n"
        report += "./gradlew build analyzeBytecodeDependencies\n\n"
        report += "# Generate this report\n"
        report += "./gradlew moduleAnalysisReport\n"
        report += "```\n"
        
        reportFile.text = report
        println "üìä Module analysis report generated: ${reportFile}"
    }
}

// Custom task to generate distribution report
tasks.register('distributionReport') {
    group = 'distribution'
    description = 'Generate comprehensive distribution report'
    
    doLast {
        def reportFile = file("$buildDir/distribution-report.md")
        reportFile.parentFile.mkdirs()
        
        def report = """# System Test Suite - Distribution Report

## Modules
- **shared**: Common utilities and UI components
- **cli**: Command-line interface
- **desktop**: Desktop GUI application  
- **service**: Web service API

## Distribution Formats

### Native Images (GraalVM)
- Ultra-fast startup times
- No JVM required
- Platform-specific binaries
- Smaller memory footprint

### JLink Images
- Custom JVM with only required modules
- Reduced size compared to full JDK
- Platform-specific

### jpackage Installers
- Native installers (.dmg, .msi, .deb)
- Embedded JVM
- System integration

### Fat JARs
- Single executable JAR
- Requires Java installation
- Cross-platform

## Build Commands

```bash
# Build all modules
./gradlew buildAll

# Create native images
./gradlew createAllNativeImages

# Create jlink images  
./gradlew createAllJlinkImages

# Package everything
./gradlew packageAll

# Module-specific packaging
./gradlew packageCli
./gradlew packageDesktop
./gradlew packageService
```

## Generated Artifacts

### CLI Module
- `system-test-cli` (native image)
- `cli/build/jlink/` (jlink image)
- Fat JAR with dependencies

### Desktop Module  
- `System Test Desktop-1.0.0.dmg` (macOS)
- `System Test Desktop-1.0.0.msi` (Windows)
- `system-test-desktop` (native image)
- `desktop/build/jlink/` (jlink image)

### Service Module
- `system-test-service` (native image)
- `service/build/jlink/` (jlink image)
- Fat JAR with dependencies

Generated on: ${new Date()}
"""
        
        reportFile.text = report
        println "Distribution report generated: ${reportFile}"
    }
}
